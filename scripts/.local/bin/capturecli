#!/usr/bin/env bash

# Exit on error, unset vars, or pipe failure
set -euo pipefail
# Safer word splitting
IFS=$'\n\t'

# --- Helper: log message with color ---
log()  { echo -e "\033[1;32m[+]\033[0m $*"; }
warn() { echo -e "\033[1;33m[!]\033[0m $*"; }
err()  { echo -e "\033[1;31m[âœ—]\033[0m $*" >&2; }

# Make bash print failing command and line number
trap 'err "Command failed on line $LINENO: $BASH_COMMAND"' ERR


# =============== step: variable initializations
#
FILE_DIR="${XDG_VIDEOS_DIR:-$HOME/Videos}"
FILE_NAME="record_$(date +'%Y-%m-%d_%H-%M-%S').mp4"
FILE_PATH="$FILE_DIR/$FILE_NAME"


USE_MIC_AUDIO=false
USE_MONITOR_AUDIO=true

USE_NOTIFICATIONS=false

ACTION=""
DELAY="0"

# =============== step: variable parsing
#
while [[ $# -gt 0 ]]; do
    case "$1" in
        --filedir=*) FILE_DIR="${1#*=}" ;;
        --filename=*) FILE_NAME="${1#*=}" ;;
        --filepath=*) FILE_PATH="${1#*=}" ;;
        --mic) USE_MIC_AUDIO=true ;;
        --monitor|--display) USE_MONITOR_AUDIO=true ;;
        --notify | -n) USE_NOTIFICATIONS=true ;;
        --delay=*) DELAY="${1#*=}" ;;
        --start|--begin) ACTION="start" ;;
        --stop |--end) ACTION="stop" ;;
        --timer) ACTION="timer" ;;
        --help) ACTION="help" ;;
        *) echo "âš ï¸ Unknown flag ignored: $1" ;;
    esac
    shift
done


# =============== step: internal variables declaration
FILE_NAME="${FILE_NAME%.*}" # remove extension if present
TIMER_FILE="$HOME/.local/state/capturecli-$FILE_NAME"


# =============== step: create recordings dir if does not exiss
[ ! -d "$FILE_DIR" ] && mkdir -p "$FILE_DIR"


# =============== step: audio and device setup
#
AUDIO_MONITOR="$(pactl get-default-sink).monitor"
MIC_INPUT="$(pactl list short sources | grep input | awk '{print $2}')"

# =============== step: Create a combined virtual sink
#
pactl load-module module-null-sink sink_name=combined_out sink_properties=device.description=CombinedOut >/dev/null
pactl load-module module-loopback source="${AUDIO_MONITOR}" sink=combined_out latency_msec=1 >/dev/null
pactl load-module module-loopback source="${MIC_INPUT}" sink=combined_out latency_msec=1 >/dev/null



# =============== step: functions and helpers

# --- Notification helper ---
notify() {
    if [[ "$USE_NOTIFICATIONS" == true ]]; then
        notify-send -a "Screen Capture" "$@"
    fi
}

# --- Cleanup function ---
cleanup_audio() {
    log "Cleaning up virtual audio sinks..."
    pactl unload-module module-loopback || true
    pactl unload-module module-null-sink || true
}

start_recording() {
    log "Starting screen recording..."
    notify "ðŸŽ¥ Recording started"

    # Optionally delay start
    if [[ "$DELAY" -gt 0 ]]; then
        log "Waiting ${DELAY}s before recording..."
        sleep "$DELAY"
    fi

    # Construct audio input string
    local AUDIO_ARGS=()
    if [[ "$USE_MONITOR_AUDIO" == true && "$USE_MIC_AUDIO" == true ]]; then
        AUDIO_ARGS=(-a "alsa_output.combined_out.monitor")
    elif [[ "$USE_MONITOR_AUDIO" == true ]]; then
        AUDIO_ARGS=(-a "$AUDIO_MONITOR")
    elif [[ "$USE_MIC_AUDIO" == true ]]; then
        AUDIO_ARGS=(-a "$MIC_INPUT")
    fi

    # Record video
    log "Saving to: $FILE_PATH"
    wf-recorder -g "$(slurp)" "${AUDIO_ARGS[@]}" -f "$FILE_PATH" &
    echo $! > "$TIMER_FILE"
}

# --- Stop recording ---
stop_recording() {
    if [[ ! -f "$TIMER_FILE" ]]; then
        err "No active recording found."
        exit 1
    fi

    local PID
    PID="$(cat "$TIMER_FILE")"
    log "Stopping recording (PID $PID)..."
    kill -INT "$PID" || true
    rm -f "$TIMER_FILE"

    sleep 1
    cleanup_audio
    notify "âœ… Recording stopped"
    log "Recording saved: $FILE_PATH"
}

# --- Show help ---
show_help() {
    cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --start / --begin        Start recording
  --stop  / --end          Stop recording
  --delay=N                Start after N seconds
  --mic                    Include microphone audio
  --monitor / --display    Include monitor audio
  --notify, -n             Show desktop notifications
  --filedir=PATH           Set output directory
  --filename=NAME          Set base name (without extension)
  --filepath=FULLPATH      Override full output path
  --help                   Show this help message
EOF
}



# =============== step: main control
#
case "$ACTION" in
    start)
        start_recording
        ;;
    stop)
        stop_recording
        ;;
    help|"")
        show_help
        ;;
    *)
        err "Unknown action: $ACTION"
        show_help
        exit 1
        ;;
esac
